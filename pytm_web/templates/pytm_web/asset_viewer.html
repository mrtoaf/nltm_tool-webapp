{% load static %}

<!doctype html>
<link rel="stylesheet" href="{% static 'pytm_web.css' %}">


<div id = 'menuBar'>
    <h2>Threat Modeling Tool</h2>
    <div class="topnav">
        <a href="#share">Share</a>
        <a href="#export">Export</a>
        <a href="#profile">Profile</a>
    </div>
</div>

<div class="lowerArea">
    <div class="modeBar">
        <img src="{% static 'assets.png' %}" width="75%" style="padding-bottom: 10px;" onclick= "showSection('assets')">
        <img src="{% static 'warnings.png' %}" width="75%" style="padding-bottom: 10px;" onclick="showSection('threats')">
        <img src="{% static 'wrench.png' %}" width="75%" style="padding-bottom: 10px;"  onclick="showSection('controls')">
        <img src="{% static 'magnify.png' %}" width="75%" style="padding-bottom: 10px;" onclick="showSection('recs')">
    </div>
    <div id="itemsBar" class="itemsBar">
        <div id="assets" class="items">
            <b>What are we working on?</b>
            <br>
            <button type="button" class="assetButton" onclick="addActor(this.innerHTML)">Actor</button>
            <button type="button" class="assetButton" onclick="addActor(this.innerHTML)">Server</button>
            <button type="button" class="assetButton" onclick="addActor(this.innerHTML)">Data Store</button>
            <br>
            <button type="button" class="assetButton" onclick="addActor(this.innerHTML)">Lambda</button>
            <button type="button" class="assetButton" onclick="addActor(this.innerHTML)">Process</button>
            <button type="button" class="assetButton" onclick="addActor(this.innerHTML)">External Entity</button>
            <br>
            <button type="button" class="assetButton" onclick="addActor(this.innerHTML)">Trust Boundry</button>
        </div>
        <div id="threats" class="items" style="display: none;" >
            <b>What could go wrong?</b>
        </div>
        <div id="controls" class="items" style="display: none;" >
            <b>What are we doing about it?</b>
        </div>
        <div id="recs" class="items" style="display: none;" >
            <b>Did we do a good enough job?</b>
        </div>
    </div>
    <!-- <img class= "dfd_assetview" id="dfd_img" src="{% static 'out.png' %}" style= "display:inline"> -->
    <div class="dfd_assetview" id = "dfd">
        
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
    var nodes = [];
    var node_count = 0;
    var area;

    window.onload = function() {
        area = d3.select('.dfd_assetview').node().getBoundingClientRect()

        var svg = d3.create("svg")
        .attr("width", area.width)
        .attr("height", area.height)
        .attr("id", "dfd_svg");
    
        dfd.append(svg.node());
    }

    window.onresize = function() {
        area = d3.select('.dfd_assetview').node().getBoundingClientRect()
        
        const svg = d3.select(document.getElementById("dfd")).select("svg");
        svg
        .attr("width", area.width)
        .attr("height", area.height)

        run_simulation();
    }
    
    function showSection(icon) {
        var divs = document.querySelectorAll('.items');
        divs.forEach(div => {
            div.style.display = "none";
        });
        document.getElementById(icon).style.display = "block";
    }

    function addActor(name) {
        var asset_text = window.prompt("Name this object:", "New " + name);
        if (asset_text == null)
            return;

        const svg = d3.select(document.getElementById("dfd")).select("svg");
        
        var start = 0;
        // NOTE: this only alters where the elements are starting **relative
        // to their group object**. if you want to alter where the group
        // itself actually starts, that's lower down in the simulation
        // where nodes are defi

        var elem_group = svg
            .append('g')
        
        switch (name) {
            case "Actor":
                elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start)
                .attr('y', start)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Server":
            elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start)
                .attr('y', start)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Data Store":
                const ellipseHeight = start
                const ellipseWidth = start
                const radX = 30;
                const radY = 15
                elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start - radX)
                .attr('y', start)
                .attr('width', radX*2)
                .attr('height', radY*3)
                .style('fill', 'white')
                .style('stroke', 'black');
                
                elem_group
                .append('ellipse')
                .attr('class', 'asset')
                .attr('cx', start)
                .attr('cy', start)
                .attr('rx', radX)
                .attr('ry', radY)
                .style('fill', 'white')
                .style('stroke', 'black');

                elem_group
                .append('ellipse')
                .attr('class', 'asset')
                .attr('cx', start)
                .attr('cy', start + 3*radY)
                .attr('rx', radX)
                .attr('ry', radY)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Process":
                elem_group
                .append('circle')
                .attr('class', 'asset')
                .attr('cx', start)
                .attr('cy', start)
                .attr('r', 30)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "External Entity":
            elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start)
                .attr('y', start)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Lambda":
            elem_group
                .append('text')
                .attr('class', 'asset_text')
                .attr('x', start)
                .attr('y', start)
                .attr('fill', 'black')
                .style("font-size", '100pt')
                .style('font-family', 'Calibri')
                .text('Î»');
                break;
            case "Trust Boundry":
            elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start)
                .attr('y', start)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .attr('stroke-dasharray','5,3')
                .style('stroke', 'black');
                break;
            default:
                console.log("ERROR: addActor() got name " + name + ", which isn't recognized as a shape");
                break;
        }

        elem_group
        .append('text')
        .attr('class', 'asset_text')
        .attr('x', start + 15)
        .attr('y', start + 15)
        .attr('text-anchor', 'middle')
        .attr('alignment-baseline', 'central') // why doesn't this work on Firefox???
        .attr('fill', 'black')
        .style("font-size", '16pt')
        .text(asset_text);

        node_count++;

        run_simulation();
    }

    function run_simulation() {
        nodes = [];
        for (let i = 0; i < node_count; i++) {
            let rand_x = Math.random()*area.width/2;
            let rand_y = Math.random()*area.height/2;

            nodes.push({
                'x': area.width/4 + rand_x,
                'y': area.height/4 + rand_y
            })
        }
        // TODO: can we make this not random actually??

        d3.forceSimulation(nodes)
        .force('x', d3.forceX(area.width / 2))
        .force('y', d3.forceY(area.height / 2))
        // .force('center', d3.forceCenter(area.width / 2, area.height / 2))
        .force('collide', d3.forceCollide().radius(100))
            .on('tick', ticked);
    }
    
    function ticked() {
        var u = d3.select('svg')
        .selectAll('g')
        .data(nodes);

        u.attr("transform", function(d) {
            return "translate("+[
                d.x,
                d.y
            ]+")"
        });
    }

</script>