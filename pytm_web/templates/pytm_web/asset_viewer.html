{% load static %}

<!doctype html>
<title>NLTM Asset Viewer</title>
<link rel="stylesheet" href="{% static 'pytm_web.css' %}">


<div id = 'menuBar'>
    <h2>Threat Modeling Tool</h2>
    <div class="topnav">
        <a href="#share">Share</a>
        <a href="#export">Export</a>
        <a href="#profile">Profile</a>
    </div>
</div>

<div class="lowerArea">
    <div class="modeBar">
        <img src="{% static 'assets.png' %}" width="75%" style="padding-bottom: 10px;" onclick= "showSection('assets')">
        <img src="{% static 'warnings.png' %}" width="75%" style="padding-bottom: 10px;" onclick="showSection('threats')">
        <img src="{% static 'wrench.png' %}" width="75%" style="padding-bottom: 10px;"  onclick="showSection('controls')">
        <img src="{% static 'magnify.png' %}" width="75%" style="padding-bottom: 10px;" onclick="showSection('recs')">
    </div>
    <div id="itemsBar" class="itemsBar">
        <div id="assets" class="items">
            <b>What are we working on?</b>
            <br>
            Add Assets
            <br>
            <button type="button" class="assetButton" onclick="addElement(this.innerHTML)">Actor</button>
            <button type="button" class="assetButton" onclick="addElement(this.innerHTML)">Server</button>
            <button type="button" class="assetButton" onclick="addElement(this.innerHTML)">Data Store</button>
            <br>
            <button type="button" class="assetButton" onclick="addElement(this.innerHTML)">Lambda</button>
            <button type="button" class="assetButton" onclick="addElement(this.innerHTML)">Process</button>
            <button type="button" class="assetButton" onclick="addElement(this.innerHTML)">External Entity</button>
            <br>
            <br>
            Add Dataflow
            <br>

            <label for="source_dropdown">Source:</label>
            <select name="source_dropdown" id="source_dropdown" disabled>
                <option value="invalid">Add an asset first!</option>
            </select>

            <br>

            <label for="target_dropdown">Target:</label>
            <select name="target_dropdown" id="target_dropdown" disabled>
                <option value="invalid">Add an asset first!</option>
            </select>

            <br>
            <button type="button" class="dataflowButton" onclick="addDataFlow(this.innerHTML)">Add Data Flow</button>
        </div>
        <div id="threats" class="items" style="display: none;" >
            <b>What could go wrong?</b>
        </div>
        <div id="controls" class="items" style="display: none;" >
            <b>What are we doing about it?</b>
        </div>
        <div id="recs" class="items" style="display: none;" >
            <b>Did we do a good enough job?</b>
        </div>
    </div>
    <!-- <img class= "dfd_assetview" id="dfd_img" src="{% static 'out.png' %}" style= "display:inline"> -->
    <div class="dfd_assetview" id = "dfd">
        
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
    // Static variables
    // TODO probably don't do this
    var nodes = [];
    var links = [];
    var node_count = 0;
    var select_count = 0;
    var area;

    // Create an SVG on page load
    window.onload = function() {
        area = d3.select('.dfd_assetview').node().getBoundingClientRect()

        var svg = d3.create("svg")
        .attr("width", area.width)
        .attr("height", area.height)
        .attr("id", "dfd_svg");
    
        dfd.append(svg.node());
    }

    // On window resize, run the force simulation again
    // so that elements don't ever get stuck off screen
    window.onresize = function() {
        area = d3.select('.dfd_assetview').node().getBoundingClientRect()
        
        const svg = d3.select(document.getElementById("dfd")).select("svg");
        svg
        .attr("width", area.width)
        .attr("height", area.height)

        run_simulation();
    }

    function update_dropdowns() {
        let select_source = document.getElementById('source_dropdown');
        let select_target = document.getElementById('target_dropdown');
        select_source.disabled = false;
        select_target.disabled = false;

        while (select_source.options.length > 0) {
            select_source.remove(0);
            select_target.remove(0);
        }
        
        const svg = d3.select(document.getElementById("dfd")).select("svg");
        svg.selectAll('.asset_text').each(function (d, i) {            
            select_source.add(new Option(d3.select(this).text()));
            select_target.add(new Option(d3.select(this).text()));
        })
    }
    
    // Toggles between the four question sections (What are we working on?, etc.)
    // Determines which one should be displayed.
    function showSection(icon) {
        var divs = document.querySelectorAll('.items');
        divs.forEach(div => {
            div.style.display = "none";
        });
        document.getElementById(icon).style.display = "block";
    }

    // When an Asset button is clicked, this is the function that tells d3
    // how to draw a new group to represent that object and add it to the svg.
    function addElement(name) {
        
        // Prompt user to name their element
        var asset_text = window.prompt("Name this object:", "New " + name);
        if (asset_text == null)
            return;

        const svg = d3.select(document.getElementById("dfd")).select("svg");
        
        
        // NOTE: this variable is used in the switch statement below to alter
        // the starting position of various shapes. HOWEVER, this only moves the
        // shape relative to its parent group, not relative to the whole canvas.
        // Also, I don't think this is changed anywhere.
        // TODO: maybe just make this a hardcoded 0 in the switch statement 
        // wherever it is used?
        var start = 0;
        
         // Create a group svg element containing the Asset shape(s) and label text
        var elem_group = svg
            .append('g')
        
        // This switch statement determines which Asset was clicked on
        // and draws the corresponding shape(s).
        switch (name) {
            case "Actor":
                elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start)
                .attr('y', start)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Server":
                elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start)
                .attr('y', start)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Data Store":
                const ellipseHeight = start
                const ellipseWidth = start
                const radX = 30;
                const radY = 15
                elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start - radX)
                .attr('y', start)
                .attr('width', radX*2)
                .attr('height', radY*3)
                .style('fill', 'white')
                .style('stroke', 'black');
                
                elem_group
                .append('ellipse')
                .attr('class', 'asset')
                .attr('cx', start)
                .attr('cy', start)
                .attr('rx', radX)
                .attr('ry', radY)
                .style('fill', 'white')
                .style('stroke', 'black');

                elem_group
                .append('ellipse')
                .attr('class', 'asset')
                .attr('cx', start)
                .attr('cy', start + 3*radY)
                .attr('rx', radX)
                .attr('ry', radY)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Process":
                elem_group
                .append('circle')
                .attr('class', 'asset')
                .attr('cx', start)
                .attr('cy', start)
                .attr('r', 30)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "External Entity":
                elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start)
                .attr('y', start)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .style('stroke', 'black');
                break;
            case "Lambda":
                elem_group
                .append('text')
                .attr('class', 'asset')
                .attr('x', start)
                .attr('y', start)
                .attr('fill', 'white')
                .style('stroke', 'black')
                .style("font-size", '100pt')
                .style('font-family', 'Calibri')
                .text('Î»');
                break;
            case "Trust Boundry":
                elem_group
                .append('rect')
                .attr('class', 'asset')
                .attr('x', start)
                .attr('y', start)
                .attr('width', 60)
                .attr('height', 60)
                .style('fill', 'white')
                .attr('stroke-dasharray','5,3')
                .style('stroke', 'black');
                break;
            default:
                // should never happen
                console.log("ERROR: addElement() got name " + name + ", which isn't recognized as a shape");
                break;
        }
        
        // Now we add a label to our generated Asset.
        elem_group
        .append('text')
        .attr('class', 'asset_text')
        .attr('x', start + 15)
        .attr('y', start + 15)
        .attr('text-anchor', 'middle')
        .attr('alignment-baseline', 'central')
        .attr('fill', 'black')
        .style("font-size", '16pt')
        .text(asset_text);

        node_count++;

        run_simulation();
        update_dropdowns();
    }

    // Tells d3 to actually run the force simulation.
    // Applies a physics force to each Asset to repel each other,
    // as well as to attract towards the center.
    // Called whenever an Asset is added or whenever the screen is resized.
    function run_simulation() {
        nodes = [];
        links = [];

        // Builds a nodes list based on how many existing Assets there are
        for (let i = 0; i < node_count; i++) {
            let rand_x = Math.random()*area.width/2;
            let rand_y = Math.random()*area.height/2;

            nodes.push({
                'id': i,
                'x': area.width/4 + rand_x,
                'y': area.height/4 + rand_y
            })
        }

        // (Attempt to) build a links list, to link each of the nodes to each other
        for (let i = 0; i < node_count; i++) {
            for (let j = 0; j < node_count; j++) {
                if (i != j) {
                    links.push({
                        'source': i,
                        'target': j,
                        'type': "Test -->",
                        'distance': 30
                    })
                }
            }
        }
        
        const svg = d3.select(document.getElementById("dfd")).select("svg");
        const link = svg.selectAll(".links")
        .data(links)
        .enter()
        .append("line")
        .attr("class", "links")

        var edgepaths = svg.selectAll(".edgepath")
        .data(links)
        .enter()
        .append('path')
        .attr('class', 'edgepath')
        .attr('fill', 'black')
        .attr('stroke', 'black')
        .attr('id', function (d, i) {return 'edgepath' + i})
        .style("pointer-events", "none");
        
        // Tells d3 how to handle forces
        d3.forceSimulation(nodes)
        .force('x', d3.forceX(area.width / 2))
        .force('y', d3.forceY(area.height / 2))
        .force('link', d3.forceLink(links))
        .force('collide', d3.forceCollide().radius(100))
            .on('tick', ticked);
    }
    
    // Tells elements how to move on each frame of the forceSimulation
    function ticked() {
        const svg = d3.select(document.getElementById("dfd")).select("svg");
        let link = svg.selectAll(".links")
        let edgepaths = svg.selectAll(".edgepath")
        // Pasted code from online
        // Please work? :pray:
        link.attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

        // Even more pasted code from online
        // Please work???? :pray:
        
        var u = d3.select('svg')
        .selectAll('g')
        .data(nodes); // NOTE: something weird about how this data() call might be
        // overwriting the datum() call we're trying to use to show which element(s)
        // are selected. why is this happening???

        u.attr("transform", function(d) {
            return "translate("+[
                d.x,
                d.y
            ]+")"
        });

        edgepaths.attr('d', d => 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y);
    }

    // DEBUG
    function addDataFlow() {
        let select_source = document.getElementById('source_dropdown');
        let select_target = document.getElementById('target_dropdown');
        let source = select_source.value;
        let target = select_target.value;

        // TODO check with Ron -- should you be able to make a dataflow from something to itself??
        if (source === target) {
            alert("Cannot add a dataflow with identical source and target!");
            return;
        }

        // let link = {
        //     'source': ,
        //     'target': ,
        //     'type': "Test -->",
        //     'distance': 30
        // }

        // links.append(link);
    }
</script>